// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.29.0
// source: agent.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export interface CreateAgentRequest {
  /** Optional session ID (auto-generated if empty) */
  sessionId: string;
  /** Agent configuration */
  config?: AgentConfig | undefined;
}

export interface AgentConfig {
  /** LLM provider: bedrock, openai, anthropic, openrouter, vertex */
  provider: string;
  /** Model ID (e.g., gpt-4o, anthropic.claude-sonnet-4-20250514-v1:0) */
  modelId: string;
  /** Sampling temperature (0.0 - 1.0) */
  temperature: number;
  /** Maximum conversation turns */
  maxTurns: number;
  /** Path to MCP servers configuration file */
  mcpConfigPath: string;
  /** Filter to specific MCP servers */
  selectedServers: string[];
  /** Filter to specific tools (format: "server:tool") */
  selectedTools: string[];
  /** Custom system prompt */
  systemPrompt: string;
  /** Enable automatic context summarization */
  enableContextSummarization: boolean;
  /** Enable context offloading for large outputs */
  enableContextOffloading: boolean;
  /** Enable streaming responses */
  enableStreaming: boolean;
  /** Custom tools with handlers on client side */
  customTools: CustomToolDefinition[];
}

export interface CustomToolDefinition {
  /** Unique tool name */
  name: string;
  /** Description for the LLM */
  description: string;
  /** JSON Schema for tool parameters */
  parameters?:
    | { [key: string]: any }
    | undefined;
  /** Timeout for tool execution in milliseconds */
  timeoutMs: number;
  /** Tool category (e.g., "utility", "data") */
  category: string;
}

export interface CreateAgentResponse {
  agentId: string;
  sessionId: string;
  status: string;
  createdAt?: Date | undefined;
  capabilities?: Capabilities | undefined;
}

export interface Capabilities {
  /** Available tools (format: "server:tool") */
  tools: string[];
  /** Connected MCP servers */
  servers: string[];
}

export interface GetAgentRequest {
  agentId: string;
}

export interface GetAgentResponse {
  agentId: string;
  sessionId: string;
  status: string;
  createdAt?: Date | undefined;
  capabilities?: Capabilities | undefined;
  tokenUsage?: TokenUsage | undefined;
}

export interface ListAgentsRequest {
}

export interface ListAgentsResponse {
  agents: AgentSummary[];
}

export interface AgentSummary {
  agentId: string;
  sessionId: string;
  status: string;
  createdAt?: Date | undefined;
}

export interface DestroyAgentRequest {
  agentId: string;
}

export interface DestroyAgentResponse {
  agentId: string;
  destroyed: boolean;
}

export interface GetTokenUsageRequest {
  agentId: string;
}

export interface TokenUsage {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  cacheTokens: number;
  reasoningTokens: number;
  llmCallCount: number;
}

export interface Costs {
  inputCost: number;
  outputCost: number;
  reasoningCost: number;
  cacheCost: number;
  totalCost: number;
}

export interface TokenUsageResponse {
  tokenUsage?: TokenUsage | undefined;
  costs?: Costs | undefined;
}

export interface ConversationRequest {
  /** Agent ID for the conversation */
  agentId: string;
  /** Client asks a question (optionally with history) */
  question?:
    | QuestionMessage
    | undefined;
  /** Client returns result of a tool call */
  toolResult?:
    | ToolResultMessage
    | undefined;
  /** Client requests cancellation */
  cancel?: CancelMessage | undefined;
}

export interface QuestionMessage {
  /** The question/prompt text */
  text: string;
  /** Optional conversation history for multi-turn */
  history: Message[];
}

export interface ToolResultMessage {
  /** Call ID from ToolCallEvent */
  callId: string;
  /** Whether tool execution succeeded */
  success: boolean;
  /** Tool output (if success) */
  result: string;
  /** Error details (if not success) */
  error?:
    | ToolError
    | undefined;
  /** Execution duration in milliseconds */
  durationMs: number;
}

export interface ToolError {
  code: string;
  message: string;
  details?: { [key: string]: any } | undefined;
}

export interface CancelMessage {
  reason: string;
}

export interface ConversationResponse {
  /** Streaming text chunk from LLM */
  textChunk?:
    | TextChunkEvent
    | undefined;
  /** Server requests tool execution from client */
  toolCall?:
    | ToolCallEvent
    | undefined;
  /** Agent event for observability */
  agentEvent?:
    | AgentEvent
    | undefined;
  /** Final response (conversation complete) */
  finalResponse?:
    | FinalResponse
    | undefined;
  /** Error event */
  error?: ErrorEvent | undefined;
}

export interface TextChunkEvent {
  /** Text content chunk */
  text: string;
  /** Whether this is thinking/reasoning (for reasoning models) */
  isThinking: boolean;
}

export interface ToolCallEvent {
  /** Unique call ID for matching result */
  callId: string;
  /** Tool name to execute */
  toolName: string;
  /** Tool arguments as JSON object */
  arguments?:
    | { [key: string]: any }
    | undefined;
  /** Timeout for this tool call in milliseconds */
  timeoutMs: number;
}

export interface FinalResponse {
  /** Final response text */
  response: string;
  /** Updated conversation messages */
  updatedMessages: Message[];
  /** Token usage for this conversation */
  tokenUsage?:
    | TokenUsage
    | undefined;
  /** Total duration in milliseconds */
  durationMs: number;
}

export interface ErrorEvent {
  /** Error code (e.g., AGENT_NOT_FOUND, ASK_FAILED) */
  code: string;
  /** Human-readable error message */
  message: string;
  /** Additional error details */
  details?:
    | { [key: string]: any }
    | undefined;
  /** If true, the stream is terminated */
  fatal: boolean;
}

export interface AgentEvent {
  /** Event type (e.g., "agent_start", "tool_call", "llm_request") */
  type: string;
  /** Event timestamp */
  timestamp?:
    | Date
    | undefined;
  /** Trace ID for distributed tracing */
  traceId: string;
  /** Span ID within the trace */
  spanId: string;
  /** Parent span ID */
  parentId: string;
  /** Correlation ID for related events */
  correlationId: string;
  /** Hierarchy level in the call stack */
  hierarchyLevel: number;
  /** Session ID */
  sessionId: string;
  /** Component that emitted the event */
  component: string;
  /** Event-specific data as JSON object */
  data?: { [key: string]: any } | undefined;
}

export interface Message {
  /** Role: "user", "assistant", "system" */
  role: string;
  /** Message content */
  content: string;
}

export interface AskRequest {
  agentId: string;
  question: string;
}

export interface AskResponse {
  response: string;
  tokenUsage?: TokenUsage | undefined;
  durationMs: number;
}

export interface AskWithHistoryRequest {
  agentId: string;
  messages: Message[];
}

export interface AskWithHistoryResponse {
  response: string;
  updatedMessages: Message[];
  tokenUsage?: TokenUsage | undefined;
  durationMs: number;
}

export interface HealthCheckRequest {
}

export interface HealthCheckResponse {
  status: string;
}

function createBaseCreateAgentRequest(): CreateAgentRequest {
  return { sessionId: "", config: undefined };
}

export const CreateAgentRequest = {
  encode(message: CreateAgentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.config !== undefined) {
      AgentConfig.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAgentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAgentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = AgentConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAgentRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      config: isSet(object.config) ? AgentConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: CreateAgentRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.config !== undefined) {
      obj.config = AgentConfig.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAgentRequest>, I>>(base?: I): CreateAgentRequest {
    return CreateAgentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAgentRequest>, I>>(object: I): CreateAgentRequest {
    const message = createBaseCreateAgentRequest();
    message.sessionId = object.sessionId ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? AgentConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseAgentConfig(): AgentConfig {
  return {
    provider: "",
    modelId: "",
    temperature: 0,
    maxTurns: 0,
    mcpConfigPath: "",
    selectedServers: [],
    selectedTools: [],
    systemPrompt: "",
    enableContextSummarization: false,
    enableContextOffloading: false,
    enableStreaming: false,
    customTools: [],
  };
}

export const AgentConfig = {
  encode(message: AgentConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.temperature !== 0) {
      writer.uint32(25).double(message.temperature);
    }
    if (message.maxTurns !== 0) {
      writer.uint32(32).int32(message.maxTurns);
    }
    if (message.mcpConfigPath !== "") {
      writer.uint32(42).string(message.mcpConfigPath);
    }
    for (const v of message.selectedServers) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.selectedTools) {
      writer.uint32(58).string(v!);
    }
    if (message.systemPrompt !== "") {
      writer.uint32(66).string(message.systemPrompt);
    }
    if (message.enableContextSummarization !== false) {
      writer.uint32(72).bool(message.enableContextSummarization);
    }
    if (message.enableContextOffloading !== false) {
      writer.uint32(80).bool(message.enableContextOffloading);
    }
    if (message.enableStreaming !== false) {
      writer.uint32(88).bool(message.enableStreaming);
    }
    for (const v of message.customTools) {
      CustomToolDefinition.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.temperature = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxTurns = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mcpConfigPath = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.selectedServers.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.selectedTools.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.systemPrompt = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.enableContextSummarization = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.enableContextOffloading = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.enableStreaming = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.customTools.push(CustomToolDefinition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentConfig {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      maxTurns: isSet(object.maxTurns) ? globalThis.Number(object.maxTurns) : 0,
      mcpConfigPath: isSet(object.mcpConfigPath) ? globalThis.String(object.mcpConfigPath) : "",
      selectedServers: globalThis.Array.isArray(object?.selectedServers)
        ? object.selectedServers.map((e: any) => globalThis.String(e))
        : [],
      selectedTools: globalThis.Array.isArray(object?.selectedTools)
        ? object.selectedTools.map((e: any) => globalThis.String(e))
        : [],
      systemPrompt: isSet(object.systemPrompt) ? globalThis.String(object.systemPrompt) : "",
      enableContextSummarization: isSet(object.enableContextSummarization)
        ? globalThis.Boolean(object.enableContextSummarization)
        : false,
      enableContextOffloading: isSet(object.enableContextOffloading)
        ? globalThis.Boolean(object.enableContextOffloading)
        : false,
      enableStreaming: isSet(object.enableStreaming) ? globalThis.Boolean(object.enableStreaming) : false,
      customTools: globalThis.Array.isArray(object?.customTools)
        ? object.customTools.map((e: any) => CustomToolDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AgentConfig): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.maxTurns !== 0) {
      obj.maxTurns = Math.round(message.maxTurns);
    }
    if (message.mcpConfigPath !== "") {
      obj.mcpConfigPath = message.mcpConfigPath;
    }
    if (message.selectedServers?.length) {
      obj.selectedServers = message.selectedServers;
    }
    if (message.selectedTools?.length) {
      obj.selectedTools = message.selectedTools;
    }
    if (message.systemPrompt !== "") {
      obj.systemPrompt = message.systemPrompt;
    }
    if (message.enableContextSummarization !== false) {
      obj.enableContextSummarization = message.enableContextSummarization;
    }
    if (message.enableContextOffloading !== false) {
      obj.enableContextOffloading = message.enableContextOffloading;
    }
    if (message.enableStreaming !== false) {
      obj.enableStreaming = message.enableStreaming;
    }
    if (message.customTools?.length) {
      obj.customTools = message.customTools.map((e) => CustomToolDefinition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentConfig>, I>>(base?: I): AgentConfig {
    return AgentConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentConfig>, I>>(object: I): AgentConfig {
    const message = createBaseAgentConfig();
    message.provider = object.provider ?? "";
    message.modelId = object.modelId ?? "";
    message.temperature = object.temperature ?? 0;
    message.maxTurns = object.maxTurns ?? 0;
    message.mcpConfigPath = object.mcpConfigPath ?? "";
    message.selectedServers = object.selectedServers?.map((e) => e) || [];
    message.selectedTools = object.selectedTools?.map((e) => e) || [];
    message.systemPrompt = object.systemPrompt ?? "";
    message.enableContextSummarization = object.enableContextSummarization ?? false;
    message.enableContextOffloading = object.enableContextOffloading ?? false;
    message.enableStreaming = object.enableStreaming ?? false;
    message.customTools = object.customTools?.map((e) => CustomToolDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCustomToolDefinition(): CustomToolDefinition {
  return { name: "", description: "", parameters: undefined, timeoutMs: 0, category: "" };
}

export const CustomToolDefinition = {
  encode(message: CustomToolDefinition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.parameters !== undefined) {
      Struct.encode(Struct.wrap(message.parameters), writer.uint32(26).fork()).ldelim();
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(32).int32(message.timeoutMs);
    }
    if (message.category !== "") {
      writer.uint32(42).string(message.category);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CustomToolDefinition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomToolDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parameters = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeoutMs = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.category = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomToolDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parameters: isObject(object.parameters) ? object.parameters : undefined,
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
      category: isSet(object.category) ? globalThis.String(object.category) : "",
    };
  },

  toJSON(message: CustomToolDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parameters !== undefined) {
      obj.parameters = message.parameters;
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomToolDefinition>, I>>(base?: I): CustomToolDefinition {
    return CustomToolDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomToolDefinition>, I>>(object: I): CustomToolDefinition {
    const message = createBaseCustomToolDefinition();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.parameters = object.parameters ?? undefined;
    message.timeoutMs = object.timeoutMs ?? 0;
    message.category = object.category ?? "";
    return message;
  },
};

function createBaseCreateAgentResponse(): CreateAgentResponse {
  return { agentId: "", sessionId: "", status: "", createdAt: undefined, capabilities: undefined };
}

export const CreateAgentResponse = {
  encode(message: CreateAgentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.capabilities !== undefined) {
      Capabilities.encode(message.capabilities, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAgentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAgentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.capabilities = Capabilities.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAgentResponse {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      capabilities: isSet(object.capabilities) ? Capabilities.fromJSON(object.capabilities) : undefined,
    };
  },

  toJSON(message: CreateAgentResponse): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.capabilities !== undefined) {
      obj.capabilities = Capabilities.toJSON(message.capabilities);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateAgentResponse>, I>>(base?: I): CreateAgentResponse {
    return CreateAgentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateAgentResponse>, I>>(object: I): CreateAgentResponse {
    const message = createBaseCreateAgentResponse();
    message.agentId = object.agentId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.capabilities = (object.capabilities !== undefined && object.capabilities !== null)
      ? Capabilities.fromPartial(object.capabilities)
      : undefined;
    return message;
  },
};

function createBaseCapabilities(): Capabilities {
  return { tools: [], servers: [] };
}

export const Capabilities = {
  encode(message: Capabilities, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tools) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.servers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Capabilities {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapabilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tools.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.servers.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Capabilities {
    return {
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => globalThis.String(e)) : [],
      servers: globalThis.Array.isArray(object?.servers) ? object.servers.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Capabilities): unknown {
    const obj: any = {};
    if (message.tools?.length) {
      obj.tools = message.tools;
    }
    if (message.servers?.length) {
      obj.servers = message.servers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Capabilities>, I>>(base?: I): Capabilities {
    return Capabilities.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Capabilities>, I>>(object: I): Capabilities {
    const message = createBaseCapabilities();
    message.tools = object.tools?.map((e) => e) || [];
    message.servers = object.servers?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetAgentRequest(): GetAgentRequest {
  return { agentId: "" };
}

export const GetAgentRequest = {
  encode(message: GetAgentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAgentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAgentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAgentRequest {
    return { agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "" };
  },

  toJSON(message: GetAgentRequest): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAgentRequest>, I>>(base?: I): GetAgentRequest {
    return GetAgentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAgentRequest>, I>>(object: I): GetAgentRequest {
    const message = createBaseGetAgentRequest();
    message.agentId = object.agentId ?? "";
    return message;
  },
};

function createBaseGetAgentResponse(): GetAgentResponse {
  return {
    agentId: "",
    sessionId: "",
    status: "",
    createdAt: undefined,
    capabilities: undefined,
    tokenUsage: undefined,
  };
}

export const GetAgentResponse = {
  encode(message: GetAgentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.capabilities !== undefined) {
      Capabilities.encode(message.capabilities, writer.uint32(42).fork()).ldelim();
    }
    if (message.tokenUsage !== undefined) {
      TokenUsage.encode(message.tokenUsage, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAgentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAgentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.capabilities = Capabilities.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tokenUsage = TokenUsage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAgentResponse {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      capabilities: isSet(object.capabilities) ? Capabilities.fromJSON(object.capabilities) : undefined,
      tokenUsage: isSet(object.tokenUsage) ? TokenUsage.fromJSON(object.tokenUsage) : undefined,
    };
  },

  toJSON(message: GetAgentResponse): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.capabilities !== undefined) {
      obj.capabilities = Capabilities.toJSON(message.capabilities);
    }
    if (message.tokenUsage !== undefined) {
      obj.tokenUsage = TokenUsage.toJSON(message.tokenUsage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAgentResponse>, I>>(base?: I): GetAgentResponse {
    return GetAgentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAgentResponse>, I>>(object: I): GetAgentResponse {
    const message = createBaseGetAgentResponse();
    message.agentId = object.agentId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.capabilities = (object.capabilities !== undefined && object.capabilities !== null)
      ? Capabilities.fromPartial(object.capabilities)
      : undefined;
    message.tokenUsage = (object.tokenUsage !== undefined && object.tokenUsage !== null)
      ? TokenUsage.fromPartial(object.tokenUsage)
      : undefined;
    return message;
  },
};

function createBaseListAgentsRequest(): ListAgentsRequest {
  return {};
}

export const ListAgentsRequest = {
  encode(_: ListAgentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAgentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAgentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListAgentsRequest {
    return {};
  },

  toJSON(_: ListAgentsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAgentsRequest>, I>>(base?: I): ListAgentsRequest {
    return ListAgentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAgentsRequest>, I>>(_: I): ListAgentsRequest {
    const message = createBaseListAgentsRequest();
    return message;
  },
};

function createBaseListAgentsResponse(): ListAgentsResponse {
  return { agents: [] };
}

export const ListAgentsResponse = {
  encode(message: ListAgentsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.agents) {
      AgentSummary.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAgentsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAgentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agents.push(AgentSummary.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAgentsResponse {
    return {
      agents: globalThis.Array.isArray(object?.agents) ? object.agents.map((e: any) => AgentSummary.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListAgentsResponse): unknown {
    const obj: any = {};
    if (message.agents?.length) {
      obj.agents = message.agents.map((e) => AgentSummary.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListAgentsResponse>, I>>(base?: I): ListAgentsResponse {
    return ListAgentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListAgentsResponse>, I>>(object: I): ListAgentsResponse {
    const message = createBaseListAgentsResponse();
    message.agents = object.agents?.map((e) => AgentSummary.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAgentSummary(): AgentSummary {
  return { agentId: "", sessionId: "", status: "", createdAt: undefined };
}

export const AgentSummary = {
  encode(message: AgentSummary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentSummary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentSummary {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: AgentSummary): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentSummary>, I>>(base?: I): AgentSummary {
    return AgentSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentSummary>, I>>(object: I): AgentSummary {
    const message = createBaseAgentSummary();
    message.agentId = object.agentId ?? "";
    message.sessionId = object.sessionId ?? "";
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseDestroyAgentRequest(): DestroyAgentRequest {
  return { agentId: "" };
}

export const DestroyAgentRequest = {
  encode(message: DestroyAgentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestroyAgentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyAgentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyAgentRequest {
    return { agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "" };
  },

  toJSON(message: DestroyAgentRequest): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestroyAgentRequest>, I>>(base?: I): DestroyAgentRequest {
    return DestroyAgentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestroyAgentRequest>, I>>(object: I): DestroyAgentRequest {
    const message = createBaseDestroyAgentRequest();
    message.agentId = object.agentId ?? "";
    return message;
  },
};

function createBaseDestroyAgentResponse(): DestroyAgentResponse {
  return { agentId: "", destroyed: false };
}

export const DestroyAgentResponse = {
  encode(message: DestroyAgentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.destroyed !== false) {
      writer.uint32(16).bool(message.destroyed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestroyAgentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestroyAgentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.destroyed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestroyAgentResponse {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      destroyed: isSet(object.destroyed) ? globalThis.Boolean(object.destroyed) : false,
    };
  },

  toJSON(message: DestroyAgentResponse): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.destroyed !== false) {
      obj.destroyed = message.destroyed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DestroyAgentResponse>, I>>(base?: I): DestroyAgentResponse {
    return DestroyAgentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DestroyAgentResponse>, I>>(object: I): DestroyAgentResponse {
    const message = createBaseDestroyAgentResponse();
    message.agentId = object.agentId ?? "";
    message.destroyed = object.destroyed ?? false;
    return message;
  },
};

function createBaseGetTokenUsageRequest(): GetTokenUsageRequest {
  return { agentId: "" };
}

export const GetTokenUsageRequest = {
  encode(message: GetTokenUsageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTokenUsageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenUsageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenUsageRequest {
    return { agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "" };
  },

  toJSON(message: GetTokenUsageRequest): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenUsageRequest>, I>>(base?: I): GetTokenUsageRequest {
    return GetTokenUsageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenUsageRequest>, I>>(object: I): GetTokenUsageRequest {
    const message = createBaseGetTokenUsageRequest();
    message.agentId = object.agentId ?? "";
    return message;
  },
};

function createBaseTokenUsage(): TokenUsage {
  return { promptTokens: 0, completionTokens: 0, totalTokens: 0, cacheTokens: 0, reasoningTokens: 0, llmCallCount: 0 };
}

export const TokenUsage = {
  encode(message: TokenUsage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.promptTokens !== 0) {
      writer.uint32(8).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(16).int32(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(24).int32(message.totalTokens);
    }
    if (message.cacheTokens !== 0) {
      writer.uint32(32).int32(message.cacheTokens);
    }
    if (message.reasoningTokens !== 0) {
      writer.uint32(40).int32(message.reasoningTokens);
    }
    if (message.llmCallCount !== 0) {
      writer.uint32(48).int32(message.llmCallCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenUsage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cacheTokens = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.reasoningTokens = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.llmCallCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenUsage {
    return {
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : 0,
      cacheTokens: isSet(object.cacheTokens) ? globalThis.Number(object.cacheTokens) : 0,
      reasoningTokens: isSet(object.reasoningTokens) ? globalThis.Number(object.reasoningTokens) : 0,
      llmCallCount: isSet(object.llmCallCount) ? globalThis.Number(object.llmCallCount) : 0,
    };
  },

  toJSON(message: TokenUsage): unknown {
    const obj: any = {};
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.cacheTokens !== 0) {
      obj.cacheTokens = Math.round(message.cacheTokens);
    }
    if (message.reasoningTokens !== 0) {
      obj.reasoningTokens = Math.round(message.reasoningTokens);
    }
    if (message.llmCallCount !== 0) {
      obj.llmCallCount = Math.round(message.llmCallCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenUsage>, I>>(base?: I): TokenUsage {
    return TokenUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenUsage>, I>>(object: I): TokenUsage {
    const message = createBaseTokenUsage();
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.cacheTokens = object.cacheTokens ?? 0;
    message.reasoningTokens = object.reasoningTokens ?? 0;
    message.llmCallCount = object.llmCallCount ?? 0;
    return message;
  },
};

function createBaseCosts(): Costs {
  return { inputCost: 0, outputCost: 0, reasoningCost: 0, cacheCost: 0, totalCost: 0 };
}

export const Costs = {
  encode(message: Costs, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inputCost !== 0) {
      writer.uint32(9).double(message.inputCost);
    }
    if (message.outputCost !== 0) {
      writer.uint32(17).double(message.outputCost);
    }
    if (message.reasoningCost !== 0) {
      writer.uint32(25).double(message.reasoningCost);
    }
    if (message.cacheCost !== 0) {
      writer.uint32(33).double(message.cacheCost);
    }
    if (message.totalCost !== 0) {
      writer.uint32(41).double(message.totalCost);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Costs {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.inputCost = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.outputCost = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.reasoningCost = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.cacheCost = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.totalCost = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Costs {
    return {
      inputCost: isSet(object.inputCost) ? globalThis.Number(object.inputCost) : 0,
      outputCost: isSet(object.outputCost) ? globalThis.Number(object.outputCost) : 0,
      reasoningCost: isSet(object.reasoningCost) ? globalThis.Number(object.reasoningCost) : 0,
      cacheCost: isSet(object.cacheCost) ? globalThis.Number(object.cacheCost) : 0,
      totalCost: isSet(object.totalCost) ? globalThis.Number(object.totalCost) : 0,
    };
  },

  toJSON(message: Costs): unknown {
    const obj: any = {};
    if (message.inputCost !== 0) {
      obj.inputCost = message.inputCost;
    }
    if (message.outputCost !== 0) {
      obj.outputCost = message.outputCost;
    }
    if (message.reasoningCost !== 0) {
      obj.reasoningCost = message.reasoningCost;
    }
    if (message.cacheCost !== 0) {
      obj.cacheCost = message.cacheCost;
    }
    if (message.totalCost !== 0) {
      obj.totalCost = message.totalCost;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Costs>, I>>(base?: I): Costs {
    return Costs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Costs>, I>>(object: I): Costs {
    const message = createBaseCosts();
    message.inputCost = object.inputCost ?? 0;
    message.outputCost = object.outputCost ?? 0;
    message.reasoningCost = object.reasoningCost ?? 0;
    message.cacheCost = object.cacheCost ?? 0;
    message.totalCost = object.totalCost ?? 0;
    return message;
  },
};

function createBaseTokenUsageResponse(): TokenUsageResponse {
  return { tokenUsage: undefined, costs: undefined };
}

export const TokenUsageResponse = {
  encode(message: TokenUsageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenUsage !== undefined) {
      TokenUsage.encode(message.tokenUsage, writer.uint32(10).fork()).ldelim();
    }
    if (message.costs !== undefined) {
      Costs.encode(message.costs, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TokenUsageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenUsageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenUsage = TokenUsage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.costs = Costs.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenUsageResponse {
    return {
      tokenUsage: isSet(object.tokenUsage) ? TokenUsage.fromJSON(object.tokenUsage) : undefined,
      costs: isSet(object.costs) ? Costs.fromJSON(object.costs) : undefined,
    };
  },

  toJSON(message: TokenUsageResponse): unknown {
    const obj: any = {};
    if (message.tokenUsage !== undefined) {
      obj.tokenUsage = TokenUsage.toJSON(message.tokenUsage);
    }
    if (message.costs !== undefined) {
      obj.costs = Costs.toJSON(message.costs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenUsageResponse>, I>>(base?: I): TokenUsageResponse {
    return TokenUsageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenUsageResponse>, I>>(object: I): TokenUsageResponse {
    const message = createBaseTokenUsageResponse();
    message.tokenUsage = (object.tokenUsage !== undefined && object.tokenUsage !== null)
      ? TokenUsage.fromPartial(object.tokenUsage)
      : undefined;
    message.costs = (object.costs !== undefined && object.costs !== null) ? Costs.fromPartial(object.costs) : undefined;
    return message;
  },
};

function createBaseConversationRequest(): ConversationRequest {
  return { agentId: "", question: undefined, toolResult: undefined, cancel: undefined };
}

export const ConversationRequest = {
  encode(message: ConversationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.question !== undefined) {
      QuestionMessage.encode(message.question, writer.uint32(18).fork()).ldelim();
    }
    if (message.toolResult !== undefined) {
      ToolResultMessage.encode(message.toolResult, writer.uint32(26).fork()).ldelim();
    }
    if (message.cancel !== undefined) {
      CancelMessage.encode(message.cancel, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConversationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.question = QuestionMessage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toolResult = ToolResultMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cancel = CancelMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationRequest {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      question: isSet(object.question) ? QuestionMessage.fromJSON(object.question) : undefined,
      toolResult: isSet(object.toolResult) ? ToolResultMessage.fromJSON(object.toolResult) : undefined,
      cancel: isSet(object.cancel) ? CancelMessage.fromJSON(object.cancel) : undefined,
    };
  },

  toJSON(message: ConversationRequest): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.question !== undefined) {
      obj.question = QuestionMessage.toJSON(message.question);
    }
    if (message.toolResult !== undefined) {
      obj.toolResult = ToolResultMessage.toJSON(message.toolResult);
    }
    if (message.cancel !== undefined) {
      obj.cancel = CancelMessage.toJSON(message.cancel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationRequest>, I>>(base?: I): ConversationRequest {
    return ConversationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationRequest>, I>>(object: I): ConversationRequest {
    const message = createBaseConversationRequest();
    message.agentId = object.agentId ?? "";
    message.question = (object.question !== undefined && object.question !== null)
      ? QuestionMessage.fromPartial(object.question)
      : undefined;
    message.toolResult = (object.toolResult !== undefined && object.toolResult !== null)
      ? ToolResultMessage.fromPartial(object.toolResult)
      : undefined;
    message.cancel = (object.cancel !== undefined && object.cancel !== null)
      ? CancelMessage.fromPartial(object.cancel)
      : undefined;
    return message;
  },
};

function createBaseQuestionMessage(): QuestionMessage {
  return { text: "", history: [] };
}

export const QuestionMessage = {
  encode(message: QuestionMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    for (const v of message.history) {
      Message.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QuestionMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.history.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionMessage {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      history: globalThis.Array.isArray(object?.history) ? object.history.map((e: any) => Message.fromJSON(e)) : [],
    };
  },

  toJSON(message: QuestionMessage): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.history?.length) {
      obj.history = message.history.map((e) => Message.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuestionMessage>, I>>(base?: I): QuestionMessage {
    return QuestionMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuestionMessage>, I>>(object: I): QuestionMessage {
    const message = createBaseQuestionMessage();
    message.text = object.text ?? "";
    message.history = object.history?.map((e) => Message.fromPartial(e)) || [];
    return message;
  },
};

function createBaseToolResultMessage(): ToolResultMessage {
  return { callId: "", success: false, result: "", error: undefined, durationMs: 0 };
}

export const ToolResultMessage = {
  encode(message: ToolResultMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.callId !== "") {
      writer.uint32(10).string(message.callId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.result !== "") {
      writer.uint32(26).string(message.result);
    }
    if (message.error !== undefined) {
      ToolError.encode(message.error, writer.uint32(34).fork()).ldelim();
    }
    if (message.durationMs !== 0) {
      writer.uint32(40).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolResultMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolResultMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.callId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.result = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = ToolError.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.durationMs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolResultMessage {
    return {
      callId: isSet(object.callId) ? globalThis.String(object.callId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      error: isSet(object.error) ? ToolError.fromJSON(object.error) : undefined,
      durationMs: isSet(object.durationMs) ? globalThis.Number(object.durationMs) : 0,
    };
  },

  toJSON(message: ToolResultMessage): unknown {
    const obj: any = {};
    if (message.callId !== "") {
      obj.callId = message.callId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.error !== undefined) {
      obj.error = ToolError.toJSON(message.error);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolResultMessage>, I>>(base?: I): ToolResultMessage {
    return ToolResultMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolResultMessage>, I>>(object: I): ToolResultMessage {
    const message = createBaseToolResultMessage();
    message.callId = object.callId ?? "";
    message.success = object.success ?? false;
    message.result = object.result ?? "";
    message.error = (object.error !== undefined && object.error !== null)
      ? ToolError.fromPartial(object.error)
      : undefined;
    message.durationMs = object.durationMs ?? 0;
    return message;
  },
};

function createBaseToolError(): ToolError {
  return { code: "", message: "", details: undefined };
}

export const ToolError = {
  encode(message: ToolError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== undefined) {
      Struct.encode(Struct.wrap(message.details), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolError {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isObject(object.details) ? object.details : undefined,
    };
  },

  toJSON(message: ToolError): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolError>, I>>(base?: I): ToolError {
    return ToolError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolError>, I>>(object: I): ToolError {
    const message = createBaseToolError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.details = object.details ?? undefined;
    return message;
  },
};

function createBaseCancelMessage(): CancelMessage {
  return { reason: "" };
}

export const CancelMessage = {
  encode(message: CancelMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reason !== "") {
      writer.uint32(10).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelMessage {
    return { reason: isSet(object.reason) ? globalThis.String(object.reason) : "" };
  },

  toJSON(message: CancelMessage): unknown {
    const obj: any = {};
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelMessage>, I>>(base?: I): CancelMessage {
    return CancelMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelMessage>, I>>(object: I): CancelMessage {
    const message = createBaseCancelMessage();
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseConversationResponse(): ConversationResponse {
  return {
    textChunk: undefined,
    toolCall: undefined,
    agentEvent: undefined,
    finalResponse: undefined,
    error: undefined,
  };
}

export const ConversationResponse = {
  encode(message: ConversationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.textChunk !== undefined) {
      TextChunkEvent.encode(message.textChunk, writer.uint32(10).fork()).ldelim();
    }
    if (message.toolCall !== undefined) {
      ToolCallEvent.encode(message.toolCall, writer.uint32(18).fork()).ldelim();
    }
    if (message.agentEvent !== undefined) {
      AgentEvent.encode(message.agentEvent, writer.uint32(26).fork()).ldelim();
    }
    if (message.finalResponse !== undefined) {
      FinalResponse.encode(message.finalResponse, writer.uint32(34).fork()).ldelim();
    }
    if (message.error !== undefined) {
      ErrorEvent.encode(message.error, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConversationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textChunk = TextChunkEvent.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toolCall = ToolCallEvent.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.agentEvent = AgentEvent.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.finalResponse = FinalResponse.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = ErrorEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationResponse {
    return {
      textChunk: isSet(object.textChunk) ? TextChunkEvent.fromJSON(object.textChunk) : undefined,
      toolCall: isSet(object.toolCall) ? ToolCallEvent.fromJSON(object.toolCall) : undefined,
      agentEvent: isSet(object.agentEvent) ? AgentEvent.fromJSON(object.agentEvent) : undefined,
      finalResponse: isSet(object.finalResponse) ? FinalResponse.fromJSON(object.finalResponse) : undefined,
      error: isSet(object.error) ? ErrorEvent.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ConversationResponse): unknown {
    const obj: any = {};
    if (message.textChunk !== undefined) {
      obj.textChunk = TextChunkEvent.toJSON(message.textChunk);
    }
    if (message.toolCall !== undefined) {
      obj.toolCall = ToolCallEvent.toJSON(message.toolCall);
    }
    if (message.agentEvent !== undefined) {
      obj.agentEvent = AgentEvent.toJSON(message.agentEvent);
    }
    if (message.finalResponse !== undefined) {
      obj.finalResponse = FinalResponse.toJSON(message.finalResponse);
    }
    if (message.error !== undefined) {
      obj.error = ErrorEvent.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationResponse>, I>>(base?: I): ConversationResponse {
    return ConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationResponse>, I>>(object: I): ConversationResponse {
    const message = createBaseConversationResponse();
    message.textChunk = (object.textChunk !== undefined && object.textChunk !== null)
      ? TextChunkEvent.fromPartial(object.textChunk)
      : undefined;
    message.toolCall = (object.toolCall !== undefined && object.toolCall !== null)
      ? ToolCallEvent.fromPartial(object.toolCall)
      : undefined;
    message.agentEvent = (object.agentEvent !== undefined && object.agentEvent !== null)
      ? AgentEvent.fromPartial(object.agentEvent)
      : undefined;
    message.finalResponse = (object.finalResponse !== undefined && object.finalResponse !== null)
      ? FinalResponse.fromPartial(object.finalResponse)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorEvent.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseTextChunkEvent(): TextChunkEvent {
  return { text: "", isThinking: false };
}

export const TextChunkEvent = {
  encode(message: TextChunkEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.isThinking !== false) {
      writer.uint32(16).bool(message.isThinking);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TextChunkEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextChunkEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isThinking = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextChunkEvent {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      isThinking: isSet(object.isThinking) ? globalThis.Boolean(object.isThinking) : false,
    };
  },

  toJSON(message: TextChunkEvent): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.isThinking !== false) {
      obj.isThinking = message.isThinking;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextChunkEvent>, I>>(base?: I): TextChunkEvent {
    return TextChunkEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextChunkEvent>, I>>(object: I): TextChunkEvent {
    const message = createBaseTextChunkEvent();
    message.text = object.text ?? "";
    message.isThinking = object.isThinking ?? false;
    return message;
  },
};

function createBaseToolCallEvent(): ToolCallEvent {
  return { callId: "", toolName: "", arguments: undefined, timeoutMs: 0 };
}

export const ToolCallEvent = {
  encode(message: ToolCallEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.callId !== "") {
      writer.uint32(10).string(message.callId);
    }
    if (message.toolName !== "") {
      writer.uint32(18).string(message.toolName);
    }
    if (message.arguments !== undefined) {
      Struct.encode(Struct.wrap(message.arguments), writer.uint32(26).fork()).ldelim();
    }
    if (message.timeoutMs !== 0) {
      writer.uint32(32).int32(message.timeoutMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ToolCallEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCallEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.callId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toolName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.arguments = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeoutMs = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCallEvent {
    return {
      callId: isSet(object.callId) ? globalThis.String(object.callId) : "",
      toolName: isSet(object.toolName) ? globalThis.String(object.toolName) : "",
      arguments: isObject(object.arguments) ? object.arguments : undefined,
      timeoutMs: isSet(object.timeoutMs) ? globalThis.Number(object.timeoutMs) : 0,
    };
  },

  toJSON(message: ToolCallEvent): unknown {
    const obj: any = {};
    if (message.callId !== "") {
      obj.callId = message.callId;
    }
    if (message.toolName !== "") {
      obj.toolName = message.toolName;
    }
    if (message.arguments !== undefined) {
      obj.arguments = message.arguments;
    }
    if (message.timeoutMs !== 0) {
      obj.timeoutMs = Math.round(message.timeoutMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCallEvent>, I>>(base?: I): ToolCallEvent {
    return ToolCallEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCallEvent>, I>>(object: I): ToolCallEvent {
    const message = createBaseToolCallEvent();
    message.callId = object.callId ?? "";
    message.toolName = object.toolName ?? "";
    message.arguments = object.arguments ?? undefined;
    message.timeoutMs = object.timeoutMs ?? 0;
    return message;
  },
};

function createBaseFinalResponse(): FinalResponse {
  return { response: "", updatedMessages: [], tokenUsage: undefined, durationMs: 0 };
}

export const FinalResponse = {
  encode(message: FinalResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    for (const v of message.updatedMessages) {
      Message.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.tokenUsage !== undefined) {
      TokenUsage.encode(message.tokenUsage, writer.uint32(26).fork()).ldelim();
    }
    if (message.durationMs !== 0) {
      writer.uint32(32).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinalResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updatedMessages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tokenUsage = TokenUsage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.durationMs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalResponse {
    return {
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      updatedMessages: globalThis.Array.isArray(object?.updatedMessages)
        ? object.updatedMessages.map((e: any) => Message.fromJSON(e))
        : [],
      tokenUsage: isSet(object.tokenUsage) ? TokenUsage.fromJSON(object.tokenUsage) : undefined,
      durationMs: isSet(object.durationMs) ? globalThis.Number(object.durationMs) : 0,
    };
  },

  toJSON(message: FinalResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    if (message.updatedMessages?.length) {
      obj.updatedMessages = message.updatedMessages.map((e) => Message.toJSON(e));
    }
    if (message.tokenUsage !== undefined) {
      obj.tokenUsage = TokenUsage.toJSON(message.tokenUsage);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalResponse>, I>>(base?: I): FinalResponse {
    return FinalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalResponse>, I>>(object: I): FinalResponse {
    const message = createBaseFinalResponse();
    message.response = object.response ?? "";
    message.updatedMessages = object.updatedMessages?.map((e) => Message.fromPartial(e)) || [];
    message.tokenUsage = (object.tokenUsage !== undefined && object.tokenUsage !== null)
      ? TokenUsage.fromPartial(object.tokenUsage)
      : undefined;
    message.durationMs = object.durationMs ?? 0;
    return message;
  },
};

function createBaseErrorEvent(): ErrorEvent {
  return { code: "", message: "", details: undefined, fatal: false };
}

export const ErrorEvent = {
  encode(message: ErrorEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== undefined) {
      Struct.encode(Struct.wrap(message.details), writer.uint32(26).fork()).ldelim();
    }
    if (message.fatal !== false) {
      writer.uint32(32).bool(message.fatal);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ErrorEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fatal = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorEvent {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isObject(object.details) ? object.details : undefined,
      fatal: isSet(object.fatal) ? globalThis.Boolean(object.fatal) : false,
    };
  },

  toJSON(message: ErrorEvent): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    if (message.fatal !== false) {
      obj.fatal = message.fatal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorEvent>, I>>(base?: I): ErrorEvent {
    return ErrorEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorEvent>, I>>(object: I): ErrorEvent {
    const message = createBaseErrorEvent();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.details = object.details ?? undefined;
    message.fatal = object.fatal ?? false;
    return message;
  },
};

function createBaseAgentEvent(): AgentEvent {
  return {
    type: "",
    timestamp: undefined,
    traceId: "",
    spanId: "",
    parentId: "",
    correlationId: "",
    hierarchyLevel: 0,
    sessionId: "",
    component: "",
    data: undefined,
  };
}

export const AgentEvent = {
  encode(message: AgentEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.traceId !== "") {
      writer.uint32(26).string(message.traceId);
    }
    if (message.spanId !== "") {
      writer.uint32(34).string(message.spanId);
    }
    if (message.parentId !== "") {
      writer.uint32(42).string(message.parentId);
    }
    if (message.correlationId !== "") {
      writer.uint32(50).string(message.correlationId);
    }
    if (message.hierarchyLevel !== 0) {
      writer.uint32(56).int32(message.hierarchyLevel);
    }
    if (message.sessionId !== "") {
      writer.uint32(66).string(message.sessionId);
    }
    if (message.component !== "") {
      writer.uint32(74).string(message.component);
    }
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AgentEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.spanId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parentId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.correlationId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.hierarchyLevel = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.component = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentEvent {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      spanId: isSet(object.spanId) ? globalThis.String(object.spanId) : "",
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
      correlationId: isSet(object.correlationId) ? globalThis.String(object.correlationId) : "",
      hierarchyLevel: isSet(object.hierarchyLevel) ? globalThis.Number(object.hierarchyLevel) : 0,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      component: isSet(object.component) ? globalThis.String(object.component) : "",
      data: isObject(object.data) ? object.data : undefined,
    };
  },

  toJSON(message: AgentEvent): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.spanId !== "") {
      obj.spanId = message.spanId;
    }
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    if (message.correlationId !== "") {
      obj.correlationId = message.correlationId;
    }
    if (message.hierarchyLevel !== 0) {
      obj.hierarchyLevel = Math.round(message.hierarchyLevel);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.component !== "") {
      obj.component = message.component;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AgentEvent>, I>>(base?: I): AgentEvent {
    return AgentEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AgentEvent>, I>>(object: I): AgentEvent {
    const message = createBaseAgentEvent();
    message.type = object.type ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.traceId = object.traceId ?? "";
    message.spanId = object.spanId ?? "";
    message.parentId = object.parentId ?? "";
    message.correlationId = object.correlationId ?? "";
    message.hierarchyLevel = object.hierarchyLevel ?? 0;
    message.sessionId = object.sessionId ?? "";
    message.component = object.component ?? "";
    message.data = object.data ?? undefined;
    return message;
  },
};

function createBaseMessage(): Message {
  return { role: "", content: "" };
}

export const Message = {
  encode(message: Message, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Message {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.role = object.role ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseAskRequest(): AskRequest {
  return { agentId: "", question: "" };
}

export const AskRequest = {
  encode(message: AskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.question !== "") {
      writer.uint32(18).string(message.question);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.question = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AskRequest {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      question: isSet(object.question) ? globalThis.String(object.question) : "",
    };
  },

  toJSON(message: AskRequest): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AskRequest>, I>>(base?: I): AskRequest {
    return AskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AskRequest>, I>>(object: I): AskRequest {
    const message = createBaseAskRequest();
    message.agentId = object.agentId ?? "";
    message.question = object.question ?? "";
    return message;
  },
};

function createBaseAskResponse(): AskResponse {
  return { response: "", tokenUsage: undefined, durationMs: 0 };
}

export const AskResponse = {
  encode(message: AskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    if (message.tokenUsage !== undefined) {
      TokenUsage.encode(message.tokenUsage, writer.uint32(18).fork()).ldelim();
    }
    if (message.durationMs !== 0) {
      writer.uint32(24).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenUsage = TokenUsage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.durationMs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AskResponse {
    return {
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      tokenUsage: isSet(object.tokenUsage) ? TokenUsage.fromJSON(object.tokenUsage) : undefined,
      durationMs: isSet(object.durationMs) ? globalThis.Number(object.durationMs) : 0,
    };
  },

  toJSON(message: AskResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    if (message.tokenUsage !== undefined) {
      obj.tokenUsage = TokenUsage.toJSON(message.tokenUsage);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AskResponse>, I>>(base?: I): AskResponse {
    return AskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AskResponse>, I>>(object: I): AskResponse {
    const message = createBaseAskResponse();
    message.response = object.response ?? "";
    message.tokenUsage = (object.tokenUsage !== undefined && object.tokenUsage !== null)
      ? TokenUsage.fromPartial(object.tokenUsage)
      : undefined;
    message.durationMs = object.durationMs ?? 0;
    return message;
  },
};

function createBaseAskWithHistoryRequest(): AskWithHistoryRequest {
  return { agentId: "", messages: [] };
}

export const AskWithHistoryRequest = {
  encode(message: AskWithHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AskWithHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAskWithHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AskWithHistoryRequest {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
    };
  },

  toJSON(message: AskWithHistoryRequest): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AskWithHistoryRequest>, I>>(base?: I): AskWithHistoryRequest {
    return AskWithHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AskWithHistoryRequest>, I>>(object: I): AskWithHistoryRequest {
    const message = createBaseAskWithHistoryRequest();
    message.agentId = object.agentId ?? "";
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAskWithHistoryResponse(): AskWithHistoryResponse {
  return { response: "", updatedMessages: [], tokenUsage: undefined, durationMs: 0 };
}

export const AskWithHistoryResponse = {
  encode(message: AskWithHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.response !== "") {
      writer.uint32(10).string(message.response);
    }
    for (const v of message.updatedMessages) {
      Message.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.tokenUsage !== undefined) {
      TokenUsage.encode(message.tokenUsage, writer.uint32(26).fork()).ldelim();
    }
    if (message.durationMs !== 0) {
      writer.uint32(32).int64(message.durationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AskWithHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAskWithHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.response = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updatedMessages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tokenUsage = TokenUsage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.durationMs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AskWithHistoryResponse {
    return {
      response: isSet(object.response) ? globalThis.String(object.response) : "",
      updatedMessages: globalThis.Array.isArray(object?.updatedMessages)
        ? object.updatedMessages.map((e: any) => Message.fromJSON(e))
        : [],
      tokenUsage: isSet(object.tokenUsage) ? TokenUsage.fromJSON(object.tokenUsage) : undefined,
      durationMs: isSet(object.durationMs) ? globalThis.Number(object.durationMs) : 0,
    };
  },

  toJSON(message: AskWithHistoryResponse): unknown {
    const obj: any = {};
    if (message.response !== "") {
      obj.response = message.response;
    }
    if (message.updatedMessages?.length) {
      obj.updatedMessages = message.updatedMessages.map((e) => Message.toJSON(e));
    }
    if (message.tokenUsage !== undefined) {
      obj.tokenUsage = TokenUsage.toJSON(message.tokenUsage);
    }
    if (message.durationMs !== 0) {
      obj.durationMs = Math.round(message.durationMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AskWithHistoryResponse>, I>>(base?: I): AskWithHistoryResponse {
    return AskWithHistoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AskWithHistoryResponse>, I>>(object: I): AskWithHistoryResponse {
    const message = createBaseAskWithHistoryResponse();
    message.response = object.response ?? "";
    message.updatedMessages = object.updatedMessages?.map((e) => Message.fromPartial(e)) || [];
    message.tokenUsage = (object.tokenUsage !== undefined && object.tokenUsage !== null)
      ? TokenUsage.fromPartial(object.tokenUsage)
      : undefined;
    message.durationMs = object.durationMs ?? 0;
    return message;
  },
};

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest = {
  encode(_: HealthCheckRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckRequest {
    return {};
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(_: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: "" };
}

export const HealthCheckResponse = {
  encode(message: HealthCheckResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== "") {
      writer.uint32(10).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return { status: isSet(object.status) ? globalThis.String(object.status) : "" };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? "";
    return message;
  },
};

export type AgentServiceService = typeof AgentServiceService;
export const AgentServiceService = {
  /** Agent Lifecycle */
  createAgent: {
    path: "/mcpagent.v1.AgentService/CreateAgent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateAgentRequest) => Buffer.from(CreateAgentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateAgentRequest.decode(value),
    responseSerialize: (value: CreateAgentResponse) => Buffer.from(CreateAgentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateAgentResponse.decode(value),
  },
  getAgent: {
    path: "/mcpagent.v1.AgentService/GetAgent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAgentRequest) => Buffer.from(GetAgentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAgentRequest.decode(value),
    responseSerialize: (value: GetAgentResponse) => Buffer.from(GetAgentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAgentResponse.decode(value),
  },
  listAgents: {
    path: "/mcpagent.v1.AgentService/ListAgents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAgentsRequest) => Buffer.from(ListAgentsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListAgentsRequest.decode(value),
    responseSerialize: (value: ListAgentsResponse) => Buffer.from(ListAgentsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListAgentsResponse.decode(value),
  },
  destroyAgent: {
    path: "/mcpagent.v1.AgentService/DestroyAgent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DestroyAgentRequest) => Buffer.from(DestroyAgentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DestroyAgentRequest.decode(value),
    responseSerialize: (value: DestroyAgentResponse) => Buffer.from(DestroyAgentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DestroyAgentResponse.decode(value),
  },
  /** Token Usage */
  getTokenUsage: {
    path: "/mcpagent.v1.AgentService/GetTokenUsage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetTokenUsageRequest) => Buffer.from(GetTokenUsageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetTokenUsageRequest.decode(value),
    responseSerialize: (value: TokenUsageResponse) => Buffer.from(TokenUsageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => TokenUsageResponse.decode(value),
  },
  /**
   * Bidirectional Streaming Conversation
   * Client sends: questions, tool results, cancel
   * Server sends: text chunks, tool calls, events, final response
   */
  converse: {
    path: "/mcpagent.v1.AgentService/Converse",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ConversationRequest) => Buffer.from(ConversationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ConversationRequest.decode(value),
    responseSerialize: (value: ConversationResponse) => Buffer.from(ConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ConversationResponse.decode(value),
  },
  /** Unary RPCs (backward compatibility, non-streaming) */
  ask: {
    path: "/mcpagent.v1.AgentService/Ask",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AskRequest) => Buffer.from(AskRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AskRequest.decode(value),
    responseSerialize: (value: AskResponse) => Buffer.from(AskResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AskResponse.decode(value),
  },
  askWithHistory: {
    path: "/mcpagent.v1.AgentService/AskWithHistory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AskWithHistoryRequest) => Buffer.from(AskWithHistoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AskWithHistoryRequest.decode(value),
    responseSerialize: (value: AskWithHistoryResponse) => Buffer.from(AskWithHistoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AskWithHistoryResponse.decode(value),
  },
  /** Health Check */
  healthCheck: {
    path: "/mcpagent.v1.AgentService/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest) => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
} as const;

export interface AgentServiceServer extends UntypedServiceImplementation {
  /** Agent Lifecycle */
  createAgent: handleUnaryCall<CreateAgentRequest, CreateAgentResponse>;
  getAgent: handleUnaryCall<GetAgentRequest, GetAgentResponse>;
  listAgents: handleUnaryCall<ListAgentsRequest, ListAgentsResponse>;
  destroyAgent: handleUnaryCall<DestroyAgentRequest, DestroyAgentResponse>;
  /** Token Usage */
  getTokenUsage: handleUnaryCall<GetTokenUsageRequest, TokenUsageResponse>;
  /**
   * Bidirectional Streaming Conversation
   * Client sends: questions, tool results, cancel
   * Server sends: text chunks, tool calls, events, final response
   */
  converse: handleBidiStreamingCall<ConversationRequest, ConversationResponse>;
  /** Unary RPCs (backward compatibility, non-streaming) */
  ask: handleUnaryCall<AskRequest, AskResponse>;
  askWithHistory: handleUnaryCall<AskWithHistoryRequest, AskWithHistoryResponse>;
  /** Health Check */
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
}

export interface AgentServiceClient extends Client {
  /** Agent Lifecycle */
  createAgent(
    request: CreateAgentRequest,
    callback: (error: ServiceError | null, response: CreateAgentResponse) => void,
  ): ClientUnaryCall;
  createAgent(
    request: CreateAgentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateAgentResponse) => void,
  ): ClientUnaryCall;
  createAgent(
    request: CreateAgentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateAgentResponse) => void,
  ): ClientUnaryCall;
  getAgent(
    request: GetAgentRequest,
    callback: (error: ServiceError | null, response: GetAgentResponse) => void,
  ): ClientUnaryCall;
  getAgent(
    request: GetAgentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAgentResponse) => void,
  ): ClientUnaryCall;
  getAgent(
    request: GetAgentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAgentResponse) => void,
  ): ClientUnaryCall;
  listAgents(
    request: ListAgentsRequest,
    callback: (error: ServiceError | null, response: ListAgentsResponse) => void,
  ): ClientUnaryCall;
  listAgents(
    request: ListAgentsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListAgentsResponse) => void,
  ): ClientUnaryCall;
  listAgents(
    request: ListAgentsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListAgentsResponse) => void,
  ): ClientUnaryCall;
  destroyAgent(
    request: DestroyAgentRequest,
    callback: (error: ServiceError | null, response: DestroyAgentResponse) => void,
  ): ClientUnaryCall;
  destroyAgent(
    request: DestroyAgentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DestroyAgentResponse) => void,
  ): ClientUnaryCall;
  destroyAgent(
    request: DestroyAgentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DestroyAgentResponse) => void,
  ): ClientUnaryCall;
  /** Token Usage */
  getTokenUsage(
    request: GetTokenUsageRequest,
    callback: (error: ServiceError | null, response: TokenUsageResponse) => void,
  ): ClientUnaryCall;
  getTokenUsage(
    request: GetTokenUsageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: TokenUsageResponse) => void,
  ): ClientUnaryCall;
  getTokenUsage(
    request: GetTokenUsageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: TokenUsageResponse) => void,
  ): ClientUnaryCall;
  /**
   * Bidirectional Streaming Conversation
   * Client sends: questions, tool results, cancel
   * Server sends: text chunks, tool calls, events, final response
   */
  converse(): ClientDuplexStream<ConversationRequest, ConversationResponse>;
  converse(options: Partial<CallOptions>): ClientDuplexStream<ConversationRequest, ConversationResponse>;
  converse(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<ConversationRequest, ConversationResponse>;
  /** Unary RPCs (backward compatibility, non-streaming) */
  ask(request: AskRequest, callback: (error: ServiceError | null, response: AskResponse) => void): ClientUnaryCall;
  ask(
    request: AskRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AskResponse) => void,
  ): ClientUnaryCall;
  ask(
    request: AskRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AskResponse) => void,
  ): ClientUnaryCall;
  askWithHistory(
    request: AskWithHistoryRequest,
    callback: (error: ServiceError | null, response: AskWithHistoryResponse) => void,
  ): ClientUnaryCall;
  askWithHistory(
    request: AskWithHistoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AskWithHistoryResponse) => void,
  ): ClientUnaryCall;
  askWithHistory(
    request: AskWithHistoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AskWithHistoryResponse) => void,
  ): ClientUnaryCall;
  /** Health Check */
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
}

export const AgentServiceClient = makeGenericClientConstructor(
  AgentServiceService,
  "mcpagent.v1.AgentService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AgentServiceClient;
  service: typeof AgentServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
